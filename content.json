[{"title":"致青春——烟花易冷","date":"2020-03-10T14:00:00.000Z","path":"2020/03/10/hello-world/","text":"繁华声遁入空门折煞了世人梦偏冷辗转一生情债又几本如你默认生死枯等枯等一圈又一圈的年轮浮图塔断了几层断了谁的魂痛直奔一盏残灯倾塌的山门容我再等历史转身等酒香醇等你弹一曲古筝 雨纷纷旧故里草木深我听闻你始终一个人斑驳的城门盘踞着老树根石板上回荡的是再等 雨纷纷旧故里草木深我听闻你仍守着孤城 城郊牧笛声落在那座野村缘份落地生根是我们 听青春迎来笑声羡煞许多人那史册温柔不肯下笔都太很烟花易冷人事易分而你在问我是否还认真 千年后累世情深还有谁在等而青史岂能不真魏书洛阳城如你在跟前世过门跟着红尘跟随我浪迹一生 雨纷纷旧故里草木深我听闻你始终一个人斑驳的城门盘踞着老树根石板上回荡的是再等"},{"title":"CSS五种方式实现Footer置底","date":"2017-04-16T14:00:00.000Z","path":"2017/04/16/css-footerset/","text":"页脚置底（Sticky footer）就是让网页的footer部分始终在浏览器窗口的底部。 当网页内容足够长以至超出浏览器可视高度时，页脚会随着内容被推到网页底部；但如果网页内容不够长，置底的页脚就会保持在浏览器窗口底部。实现方法1. 将内容部分的底部外边距设为负数这是个比较主流的用法，把内容部分最小高度设为100%，再利用内容部分的负底部外边距值来达到当高度不满时，页脚保持在窗口底部，当高度超出则随之推出的效果。html:123456789&lt;body&gt; &lt;div class=\"wrapper\"&gt; content &lt;div class=\"push\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011121314html, body &#123; height: 100%; margin: 0;&#125;.wrapper &#123; min-height: 100%; /* 等于footer的高度 */ margin-bottom: -50px;&#125;.footer,.push &#123; height: 50px;&#125; 这个方法需要容器里有额外的占位元素（如.push） 需要注意的是.wrapper的margin-bottom值需要和.footer的负的height值保持一致，这一点不太友好。 2. 将页脚的顶部外边距设为负数既然能在容器上使用负的margin bottom，那能否使用负margin top吗？当然可以。 给内容外增加父元素，并让内容部分的底部内边距与页脚高度的值相等。12345678&lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"content-inside\"&gt; content &lt;/div&gt; &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456789101112131415html, body &#123; height: 100%; margin: 0;&#125;.content &#123; min-height: 100%;&#125;.content-inside &#123; padding: 20px; padding-bottom: 50px;&#125;.footer &#123; height: 50px; margin-top: -50px;&#125; 不过这种方法和上一种一样，都需要额外添加不必要的html元素。 3. 使用calc()设置内容高度有一种方法不需要任何多余元素——使用CSS3新增的计算函数calc() 这样元素间就不会有重叠发生，也不需要控制内外边距了～123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456.content &#123; min-height: calc(100vh - 70px);&#125;.footer &#123; height: 50px;&#125; 可能你会疑惑内容高度calc()中为什么减去70px，而不是footer的高度50px，因为假设俩元素有20px的间距，所以70px=50px+20px 4. 使用flexbox弹性盒布局以上三种方法的footer高度都是固定的，通常来说这不利于网页布局：内容会改变，它们都是弹性的，一旦内容超出固定高度就会破坏布局。所以给footer使用flexbox吧，让它的高度可以变大变小变漂亮~（≧∇≦）123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 1234567891011html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: flex; flex-direction: column;&#125;.content &#123; flex: 1;&#125; 你还可以在上面添加header或在下面添加更多元素。可从以下技巧选择其一： flex: 1 使内容（如：.content）高度可以自由伸缩 margin-top: auto 5. 使用Grid网格布局grid比flexbox还要新很多，并且更佳很简洁123456&lt;body&gt; &lt;div class=\"content\"&gt; content &lt;/div&gt; &lt;footer class=\"footer\"&gt;&lt;/footer&gt;&lt;/body&gt; 123456789101112html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: grid; grid-template-rows: 1fr auto;&#125;.footer &#123; grid-row-start: 2; grid-row-end: 3;&#125; 遗憾的是，网格布局（Grid layout）目前仅支持Chrome Canary和Firefox Developer Edition版本。 原文链接（http://t.cn/RJ3nmhV ）"},{"title":"VUE+AXIOS实现登录拦截Demo","date":"2017-04-09T14:00:00.000Z","path":"2017/04/09/vue-axios-token/","text":"一个项目学会vue全家桶+axios实现登录、拦截、登出功能，以及利用axios的http拦截器拦截请求和响应。 前言通过这个项目学习如何实现一个前端项目中所需要的登录及拦截、登出、token失效的拦截及对应 axios 拦截器的使用。准备你需要先熟悉axios文档（https://github.com/mzabriskie/axios）。 发起http请求的方法 http 请求成功时返回的数据及其类型 http请求失败的处理 拦截器的使用 http的配置 src下项目结构此项目demo是由vue-cli脚手架生成12345678910111213141516171819202122232425262728293031323334353637383940414243|__ api // 配置api接口文件 |__ account.js |__ App.vue|__ assets // 资源文件 |__ css |__ base.scss |__ min.scss |__ personal.scss |__ js // 公共的function |__ pubFunc.js|__ components |__ Spinner.vue|__ main.js|__ page |__ center |__ index.vue |__ market |__ index.vue |__ personal // 登陆组件 |__ login.vue |__ register.vue |__ resetPassword.vue |__ routerview |__ index.vue |__ tool |__ index.vue |__ viewing |__ index.vue|__ router |__ index.js // 配置路由 |__ router.js // 路由定义|__ store // 状态管理 |__ global |__ actions.js |__ getters.js |__ index.js |__ mutations.js |__ mutations_types.js |__ state.js |__ index.js|__ utils |__ httpconfig.js // 二次封装axios请求及http 拦截器配置文件 |__ localstorage.js //利用class封装本地存储方法 技术栈 Vue 2.0 vue-router vuex axios sass 登录拦截逻辑第一步：路由拦截本项目是每次进来要强制先登陆的，所以路由定义不用添加自定义字段用于判断该路由是否要先登陆 定义完路由后，我们主要是利用vue-router提供的钩子函数beforeEach()对路由进行判断。12345678910111213router.beforeEach((to, from, next) =&gt; &#123; if (!window.localStorage.getItem('token') &amp;&amp; to.path !== '/' &amp;&amp; to.path !== '/register' &amp;&amp; to.path !== '/resetpassword') &#123; // 判断没有本地存储token,如果不是跳转登陆注册修改密码，则跳转到登陆 next('/'); &#125; else &#123; if (window.localStorage.getItem('token') &amp;&amp; to.path === '/') &#123; //判断如果有本地存储token，用户打开应用则跳转到首页 next(&#123; path: '/routerview' &#125;); &#125; else &#123; next(); &#125; &#125;&#125;) 每个钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 确保要调用 next 方法，否则钩子就不会被 resolved。 完整的方法见/src/router.js 登录拦截到这里就结束了吗？并没有。这种方式只是简单的前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。 第二步：拦截器要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置http response inteceptor，当后端接口返回401 Unauthorized（未授权），让用户重新登录。123456789101112131415161718192021222324252627282930313233// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; store.dispatch('show_loading'); if(store.state.global.token)&#123; config.headers.Authorization = 'Bearer '+ `$&#123;store.state.global.token&#125;`; &#125;; return config;&#125;, function (error) &#123; store.dispatch('hide_loading'); return Promise.reject(error);&#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; store.dispatch('hide_loading'); return response;&#125;, function (error) &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 返回 401 清除token信息并跳转到登录页面 store.dispatch('remove_token'); router.replace(&#123; path: '/', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;) &#125; &#125; store.dispatch('hide_loading'); return Promise.reject(error) // 返回接口返回的错误信息&#125;); 完整的方法见/src/utils/httpconfig.js. 通过上面这两步，就可以在前端实现登录拦截了。登出功能也就很简单，只需要把当前token清除，再跳转到首页即可。 ``` 另一种情况是应用一开始不是强制用户先登陆，而是进入应用之后，跳转路由才去判断用户需不需要用户先登陆才能进行下一步操作这个业务情景我也帮你们找到demo了"},{"title":"像素级细节：移动端1px border的实现","date":"2017-04-01T12:11:00.000Z","path":"2017/04/01/thinner-than-1px-border/","text":"请记住，每个尽责的设计师都是处女座… 这里…没有黑处女座的意思，只是想借题发挥，并由衷的跪倒在强大的“像素眼”之下。 ###一、你是我的眼 什么是像素眼？就是那些个神奇的存在，他们用余光瞄了你一眼，然后跟你说：我发现啊，你左边眉毛比右边眉毛高了1像素，麻烦你调整下… 在腾讯，我身边的许多设计同学都有这样的眼睛。他们会把细节做到极致，也会因为频繁的修改，把你开发的心情搞得一团糟。但你得承认，他们是对的。 最近在做移动端web开发，按着设计图，toby已在我旁边核对修改了两个多小时。当我觉得已经万事大吉时，toby跟我说，还是觉得不太对——边框好像有点粗？ 当时我就傻眼了，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。于是我去解释，并建议更换个色值，让边框至少“看起来”更细。而toby却不接受，按他给我的说法是：这border看起来不性感… 原来这世界的审美观，都是以瘦为美，从女人到一根线？于是乎，为了寻找性感的border，搜集一堆资料后还真找到了方案： 父元素设置：scale(0.5,0.5) 子元素设置：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top 这样父元素的border其实被缩放了，无疑更细。 ###二、通用方案 用一个css类去为block元素添加更细的border1234567891011121314151617.border-1px&#123; position: relative; &amp;:before, &amp;:after&#123; border-top: 1px solid #c8c7cc; content: ' '; display: block; width: 100%; position: absolute; left: 0; &#125; &amp;:before&#123; top: 0; &#125; &amp;:after&#123; bottom: 0; &#125;&#125; 适应移动设备：123456789101112131415161718192021@media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.7); -webkit-transform-origin: 0 0; transform: scaleY(.7); &#125; &amp;::after&#123; -webkit-transform-origin: left bottom; &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.5); transform: scaleY(.5); &#125; &#125;&#125; The End.原文链接（http://litten.me/）"}]